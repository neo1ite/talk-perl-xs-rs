* Rust inside Perl
  Writing Perl extensions using Rust instead of XS
#+STARTUP: overview hideblocks
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_title_slide:nil reveal_notes:t
#+REVEAL_ROOT: node_modules/reveal.js
#+REVEAL_THEME: black
#+REVEAL_TRANS: fade
#+REVEAL_EXTRA_CSS: talk.css
#+REVEAL_MARGIN: 0.0
#+HTML_HEAD: <link rel="stylesheet" href="notes.css"/>
#+PROPERTY: mkdirp yes
#+BEGIN_src elisp :exports none
  (org-export-define-derived-backend 'html-notes 'html
    :export-block '("NOTES")
    :translate-alist
    '((export-block . (lambda (el contents info)
                        (if (string= (org-element-property :type el) "NOTES")
                            (format "<div class=\"notes\">%s</div>"
                                    (org-export-string-as
                                     (org-element-property :value el)
                                     'html
                                     t)))))))
  (org-export-to-buffer 'html-notes "*Org Notes Export*")
#+END_src
# Local Variables:
# org-html-postamble: nil
# End:
* COMMENT Quotes
  16:18 <@steveklabnik> the whole idea of rust is that 'well if i'm careful it's okay' is a bad strategy

  The purpose of type systems goes far beyond type safety: They (also) serve to establish safe abstractions.

  Types are extremely important because they prevent us from writing nonsense.

  However, experience also shows that “being careful” and extensive testing is a time sink. Often, these efforts also leave serious errors in the code, causing crashes and security violations. We must do better.
  -- Bjarne Stroustrup, 2015
** Make illegal states unrepresentable
   you cannot construct values that contradict some desired invariants
* What is XS
  #+BEGIN_NOTES
  Perl is a high-level language, that allows us to write complicated programs easily, but it comes with a cost - it is somewhat slow, but most of the time it doesn't matter. Some things are very slow in Perl, like parsing binary protocols or doing complicated math. 

  For these rare cases where performance matters, Perl has a C API and a set of supporting tools, known together as XS. The problem with XS is that we are programming in Perl because we don't want to program in C to begin with (perhaps because it is too low-level, error-prone or just unfamiliar).
  #+END_NOTES
* What is Rust
  #+BEGIN_NOTES
  Rust is a new programming language, that targets roughly the same niche as C++, being a low-level language with a lot of manual control over things, but still providing higher-level tools to the programmer. One of main goals of Rust eliminate bugs caused by improper use of memory pointers, the bane of all reasonably complicated C or C++ programs.
  #+END_NOTES
* C example
  #+BEGIN_SRC perl :tangle xs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/Foo.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c +n :tangle xs/Foo.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        SV **svp = av_fetch(av, 0, 0);  // my $svp = $Foo::array[0];
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = SvIV(*svp);
      }
      OUTPUT:
        RETVAL
  #+END_SRC
  #+BEGIN_NOTES
  A lot of XS functions return a null pointer to signal an absense of value, which is a very common pattern in C. Documxentation often mentions when a null pointer may be returned or if it acceptable as a parameter, but compilers do not read documentation and won't warn the developer if a pointer value is used inaproppriately.

  On the slide is a simple XS function that, despite being 4 lines long, can crash in a number of different ways, taking the whole interpreter with it each time.

  =get_av()= on line 6 returns a pointer to a global array variable and will return a null pointer if variable does not exist. =av_fetch()= on line 7 tries to get an element 0 from the array, and will crash if array pointer is null. =av_fetch()= will return a null pointer itself if the array is empty. On line 9 we call =SvIV()= to get the integer value of the array's element and it will crash too if the svp is null.

  But before that, on line 8, we call a perl sub called =routine=, which can introduce yet another bug in the code. Perl intentionally does not track pointers returned by get_av or av_fetch, so it doesn't know we still have them around and if routine, say, empties the array...
  #+END_NOTES
* Perl
  #+BEGIN_SRC perl -n :tangle lib/Foo.pm :exports none
    package Foo;
    use strict;
    use warnings;
    use feature 'say';
    use XSLoader;
    XSLoader::load();
  #+END_SRC
  #+BEGIN_SRC perl -n :tangle lib/Foo.pm
    package Foo;

    our @array = (1, 2, 3);

    sub routine {
        @array = ();
    }

    say Foo::badsub();

    1;
  #+END_SRC
  #+BEGIN_NOTES
  ...which it of course does (this is an example after all), we get another kind of error, a dangling pointer - it is not null, but points to a region of memory that was returned to the operating system and our program crashes again.
  #+END_NOTES
* C example fixed
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        if (av == NULL) croak("array is missing");

        SV **svp = av_fetch(av, 0, 0);
        if (svp == NULL) croak("element is missing");

        IV val = SvIV(*svp);

        PUSHMARK(SP);
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = val;
      }
      OUTPUT:
        RETVAL
  #+END_SRC
  #+BEGIN_NOTES
  To fix these problems we have to check all returned values and to make sure that we read svp as soon as we get it, before calling the routine. Rust won't do these things for us, but it can make sure we don't forget to check things that need to be checked.
  #+END_NOTES
* NULL pointers
  #+BEGIN_NOTES
  Lets deal with null pointers first.
  #+END_NOTES
** =enum= type
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer,
     }
     let drink = Drinks::Cola;
   #+END_SRC
   #+BEGIN_NOTES
   If you have worked with C, enum will look familiar. Here =Drinks= is a type that has only two possible values, =Cola= and =Beer=. We can make variable of =Drinks= and assign it one of the two values.
   #+END_NOTES
** With data
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer(String),
     }
     let drink = Drinks::Beer("Lager".to_string());
   #+END_SRC
   #+BEGIN_NOTES
   Enum variants in Rust can have additional data associated with them. Here, Cola is still a simple value, but Beer also has a String describing what kind of beer it is.
   #+END_NOTES
   #+ATTR_REVEAL: :frag t
   #+BEGIN_SRC rust +n
     match drink {
         Drinks::Cola => println!("Just cola"),
         Drinks::Beer(ref kind) => println!("{} beer", kind),
     }
   #+END_SRC
   #+BEGIN_NOTES
   The only way Rust allows us to access that string, is to check that drink is indeed a Beer. =match= operator is one way to do this. On the left side listed are enum variants, and on the right after the arrow code that will be executed in that case. If a variant has associated data, we can assign it to a variable, but it is important to note this variable only exists in one particular case.
   #+END_NOTES
** Back to pointers
   #+BEGIN_SRC rust -n
     enum SafeSVPtr {
         Null,
         NotNull(*mut SV),
     }
   #+END_SRC
   #+BEGIN_NOTES
   Just what we need to avoid null pointers. Instead of returning a pointer directly, we can put it inside an enum with a separate case for null, and dereferencing null pointer becomes impossible. This pattern applies not only to pointers of course, and is useful in so many different situations...
   #+END_NOTES
** Using standard library
   #+BEGIN_SRC rust -n
     enum Option<T> {
         None,
         Some(T),
     }
   #+END_SRC
   #+BEGIN_NOTES
   ...that Rust has enum just like that in the standard library. Letter 'T' in angle brackets on line 1 is called type parameter, which allows Option to hold all kinds of different types. match operator is often too bulky and verbose, so option comes with a variety of...
   #+END_NOTES
** Useful methods
   #+REVEAL_HTML: <table width="100%"><tr><td width="50%">
   Rust
   #+BEGIN_SRC rust
      foo.is_some()

      foo.expect("oh noes")

      foo.unwrap_or("default value")
   #+END_SRC
   #+BEGIN_NOTES
   ...useful methods. Here are a couple of examples, but there are many more. =is_some()= will return boolean true if foo is Some, =expect()= returns the value if there is one and throws a runtime exception if there isn't and =unwrap_or()= returns the value from Some or a default value provided by the caller.
   #+END_NOTES

   #+REVEAL_HTML: </td><td width="50%">
   #+ATTR_REVEAL: :frag t
   Perl
   #+ATTR_REVEAL: :frag t
   #+BEGIN_SRC perl
      defined $foo

      $foo or die "oh noes"

      $foo // "default value"
    #+END_SRC
   #+REVEAL_HTML: </td></tr></table>
   #+BEGIN_NOTES
   Many of these functions have direct equivalent in Perl as well.
   #+END_NOTES
** Example
   #+BEGIN_SRC perl -n :tangle rs-fail1/Makefile.PL :exports none
     use inc::Module::Install;

     name "Foo";
     version "0.01";
     abstract "";

     rust_use_perl_xs { path => "../../perl-xs" };
     rust_write;

     WriteAll;
   #+END_SRC
   #+BEGIN_SRC rust :exports none :tangle rs-fail1/src/lib.rs
     #[macro_use]
     extern crate perl_xs;
     use perl_xs::{ Array, SV, AV };
     XS! {
         package Test {
             sub test (ctx) {
   #+END_SRC
   #+BEGIN_SRC rust -n :tangle rs-fail1/src/lib.rs
     let av: Option<AV> = ctx.get_av(cstr!("array"));

     let sv: Option<SV> = av.fetch(0);
      
   #+END_SRC
   #+BEGIN_SRC rust :exports none :tangle rs-fail1/src/lib.rs
             }
         }
         loader boot_Test;
     }
   #+END_SRC
   #+BEGIN_SRC text
     src/lib.rs:9:13: 9:21 error: no method named `fetch` found
                                  for type `core::option::Option<_>`
                                  in the current scope
     src/lib.rs:9 let sv: Option<SV> = av.fetch(0);
                                          ^~~~~~~~
   #+END_SRC
   #+BEGIN_NOTES
   So, the first two lines of the C example I started with end up looking like this in Rust. let keyword introduces new variables, then comes the variable name and its type after the colon. Variable types are optional most of the time, but here I write them for illustration. In Rust, both =get_av()= and =av_fetch()= return an Option instead of a pointer. And since av is an option, instead of the array, this code does not compile.
   #+END_NOTES
** Example
   #+BEGIN_SRC rust -n
     let av:        AV  = ctx.get_av(cstr!("array"))
                             .expect("array is missing");
     let sv:        SV  = av.fetch(0)
                            .expect("element is missing");
   #+END_SRC
   #+REVEAL_HTML: <pre class="src src-text"><br><br><br><br><br></pre>
   #+BEGIN_NOTES
   To fix the error we need to check if option contains the value we want, for example by using .expect() method. This code handles the possibility that array will be missing, and thus compiles without problem.
   #+END_NOTES
* Dangling pointers
** Traits
   #+BEGIN_SRC rust -n
     struct Square { side: f32 }
     struct Circle { radius: f32 }

     trait Area {
         fn area(&self) -> f32;
     }

     impl Area for Square {
         fn area(&self) -> f32 {
             self.side * self.side
         }
     }
     impl Area for Circle {
         fn area(&self) -> f32 {
             self.radius * self.radius * 3.14
         }
     }
   #+END_SRC
** From
   #+BEGIN_SRC rust -n
     trait FromSV {
         fn from(src: *mut SV) -> Self;
     }

     impl FromSV for IV {
         fn from(src: *mut SV) -> IV { /* ... */ }
     }
     impl FromSV for NV {
         fn from(src: *mut SV) -> NV { /* ... */ }
     }

     fn av_fetch<T: FromSV>(array: *mut AV, idx: IV) -> T {
         T::from(perl_av_fetch(array, idx))
     }

     /* ... */
     let num: IV = av_fetch(my_array, 1, 0);
   #+END_SRC
** FromSV for SV
   #+BEGIN_SRC perl -n
     my $x = $array[0];  # a copy of value
     my $y = \$array[1]; # a reference
   #+END_SRC
   #+BEGIN_SRC c -n
     SV* x = newSVsv(av_fetch(array, 0)); // copy
     SV* y = SvREFCNT_inc(av_fetch(array, 1)); // reference (kinda)
   #+END_SRC
* In Rust
  #+BEGIN_SRC perl -n :tangle rs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    rust_use_perl_xs { path => "../../perl-xs" };
    rust_write;

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs :exports none
    #[macro_use]
    extern crate perl_xs;
    use perl_xs::{ SV, AV, Scalar, Array };
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs
    XS! {
        package Foo {
            sub badsub(ctx) {
                let av = ctx.get_av::<Option<AV>>(cstr!("array"))
                            .expect("array is missing");
                let sv = av.fetch::<Option<SV>>(0)
                           .expect("element is missing");
                // ctx.new_call("routine").as_void().discard().call();
                xs_return!(ctx, sv.to_iv() * 2);
            }
        }
        loader boot_Foo;
    }
  #+END_SRC
  #+BEGIN_NOTES
    http://is.gd/hDZvNU
  #+END_NOTES
* Implementation details
** libouroboros for perl macros
** perl-sys for function declarations
** perl-xs for safe wrappers
* Drawbacks
** Less platforms supported
   No IBM z/390 or MS-DOS support :-(
** Need to learn Rust
** No ppport.h for easy forward/backward compatibility
** No direct access to Perl internals
** Possibly will be less efficient that hand-crafted C
