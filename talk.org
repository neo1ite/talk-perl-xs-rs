* Writing Perl extensions in Rust

  Vickenty Fesunov

  #+INCLUDE: email.txt

  http://github.com/vickenty/perl-xs

  #+BEGIN_NOTES
  name
  job
  #+END_NOTES

#+STARTUP: overview hideblocks
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_title_slide:nil reveal_notes:t
#+REVEAL_ROOT: node_modules/reveal.js
#+REVEAL_THEME: black
#+REVEAL_TRANS: fade
#+REVEAL_EXTRA_CSS: talk.css
#+REVEAL_MARGIN: 0.0
#+HTML_HEAD: <link rel="stylesheet" href="notes.css"/>
#+PROPERTY: mkdirp yes
#+BEGIN_src elisp :exports none
  (org-export-define-derived-backend 'html-notes 'html
    :export-block '("NOTES")
    :translate-alist
    '((export-block . (lambda (el contents info)
                        (if (string= (org-element-property :type el) "NOTES")
                            (format "<div class=\"notes\">%s</div>"
                                    (org-export-string-as
                                     (org-element-property :value el)
                                     'html
                                     t)))))))
  (org-export-to-buffer 'html-notes "*Org Notes Export*")
#+END_src
# Local Variables:
# org-html-postamble: nil
# End:
* We're hiring
  http://workingatbooking.com
  #+BEGIN_NOTES
  come talk to us
  #+END_NOTES
* XS
  #+BEGIN_NOTES
  perl in c
  great power great resp
  perl checks, c assumes
  #+END_NOTES
* C is not easy
  #+BEGIN_NOTES
  perl reference, c pointer deref
  #+END_NOTES
** null pointers
   #+BEGIN_SRC c
     AV* array = get_av("array", 0);
     SV** item = av_fetch(array, 0);
   #+END_SRC
   #+BEGIN_NOTES
   functions return null
   dereferencing not okay
   must check
   #+END_NOTES
** dangling pointers
   #+BEGIN_SRC c
     SV** item = av_fetch(array, 0);
     av_clear(array);
     char *buf = SvPV_nolen(*item);
   #+END_SRC
   #+BEGIN_NOTES
   unlike perl, no refcount
   must track lifetime
   reading from released memory
   #+END_NOTES
** buffer overflows
   #+BEGIN_SRC c
     char *buf = SvPV_nolen(*item);
     sprintf(buf, "%d", rand());
   #+END_SRC
   #+BEGIN_NOTES
   keep track of size of memory
   don't write things you don'w want overwritten
   #+END_NOTES
** and more
   * uninitialized variables
   * sequence points
   * integer overflows
   * aliasing rules
   * data races
   #+BEGIN_NOTES
   15 pages
   #+END_NOTES
* Perl XS API is not easy
** What does this function return?
   #+BEGIN_SRC c
     SSize_t av_len(AV* array_ptr);
   #+END_SRC
** reference counting
   #+BEGIN_SRC c
   XPUSHs(av_fetch(array, 0))
   // but
   XPUSHs(sv_2mortal(av_delete(array, 0)))
   #+END_SRC
   #+BEGIN_NOTES
   same pointer, different actions
   #+END_NOTES
** exceptions
   #+BEGIN_SRC c
   FILE *f = fopen("output", "w");
   fprintf(f, "%d", SvIV(value));
   fclose(f);
   #+END_SRC
* Just be careful, okay?
  #+BEGIN_NOTES
  not to say perl, xs or c are bad
  a lot to worry, stakes are high
  #+END_NOTES
  #+BEGIN_QUOTE
   We must do better.
   #+END_QUOTE
  --- Bjarne Stroustrup, 2015
  #+REVEAL_HTML: <small> http://www.stroustrup.com/resource-model.pdf </small>
* Rust
  #+ATTR_REVEAL: :frag (reveal)
  - unsafe code
  - safe abstractions
* Rust XS
  safe code â†’ no segfaults
** sum array
   #+BEGIN_SRC rust -n
     xs! {
         package Array::Util;

         sub sum_array(ctx) {








             xs_return!(ctx, 0.0);
         }
     }
   #+END_SRC
** sum array
   #+BEGIN_SRC rust -n
     xs! {
         package Array::Util;

         sub sum_array(ctx) {
             let param: SV = ctx.st_fetch(0);







             xs_return!(ctx, 0.0);
         }
     }
   #+END_SRC
** sum array
   #+BEGIN_SRC rust -n
     xs! {
         package Array::Util;

         sub sum_array(ctx) {
             let param: SV = ctx.st_fetch(0);
             let array: AV = param.deref_av();






             xs_return!(ctx, 0.0);
         }
     }
   #+END_SRC
** sum array
   #+BEGIN_SRC rust -n
     xs! {
         package Array::Util;

         sub sum_array(ctx) {
             let param: SV = ctx.st_fetch(0);
             let array: AV = param.deref_av(); 
             //   ERROR: AV expected, but have Option<AV>





             xs_return!(ctx, 0.0);
         }
     }
   #+END_SRC
** sum array
   #+BEGIN_SRC rust -n
     xs! {
         package Array::Util;

         sub sum_array(ctx) {
             let param: SV = ctx.st_fetch(0);
             let array: AV = param.deref_av().expect("not an array ref");






             xs_return!(ctx, 0.0);
         }
     }
   #+END_SRC
** sum array
   #+BEGIN_SRC rust -n
     xs! {
         package Array::Util;

         sub sum_array(ctx) {
             let param: SV = ctx.st_fetch(0);
             let array: AV = param.deref_av().expect("not an array ref");
             let mut sum = 0.0;
             for index in 0..array.top_index() + 1 {
             


             }
             xs_return!(ctx, sum);
         }
     }
   #+END_SRC
** sum array
   #+BEGIN_SRC rust -n
     xs! {
         package Array::Util;

         sub sum_array(ctx) {
             let param: SV = ctx.st_fetch(0);
             let array: AV = param.deref_av().expect("not an array ref");
             let mut sum = 0.0;
             for index in 0..array.top_index() + 1 {
                 if let Some(item) = array.fetch(index) {
                     sum += item;
                 }
             }
             xs_return!(ctx, sum);
         }
     }
   #+END_SRC
** sum array
   #+BEGIN_SRC rust -n
     sub sum_array(ctx) {
         let param: SV = ctx.st_fetch(0);
         let array: AV = param.deref_av().expect("not an array ref");
         let sum: NV = array.iter()
             .map(|v| v.unwrap_or(0.0))
             .sum();
         xs_return!(ctx, sum);
     }
   #+END_SRC
* Benchmarks
   | Perl      | 2.072s | 100% |
   | Rust loop | 0.691s |  33% |
   | Rust iter | 0.690s |  33% |
   | XS        | 0.150s |   7% |
   #+TBLFM: $3 = 100 * $2 / @1$2 ; %d%%
* Conclusion
  #+ATTR_REVEAL: :frag (reveal)
  * it works
  * it is safer
  * it is slower
* FIN
  #+BEGIN_SRC rust
     xs! {
         package Array::Util;

         sub sum_array(ctx) {
             let param: SV = ctx.st_fetch(0);
             let array: AV = param.deref_av().expect("not an array ref");
             let mut sum = 0.0;
             for index in 0..array.top_index() + 1 {
                 if let Some(item) = array.fetch(index) {
                     sum += item;
                 }
             }
             xs_return!(ctx, sum);
         }
     }
  #+END_SRC
  http://github.com/vickenty/perl-xs
