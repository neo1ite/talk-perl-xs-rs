* Writing Perl extensions in Rust
  Vickenty Fesunov

  #+INCLUDE: email.txt

  github.com/vickenty

  #+BEGIN_NOTES
  I was playing with a Rust API for Perl for a while now, and even though it is still far from being ready, I'd like to share what's done so far and why I think it is a good idea.
  #+END_NOTES

#+STARTUP: overview hideblocks
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_title_slide:nil reveal_notes:t
#+REVEAL_ROOT: node_modules/reveal.js
#+REVEAL_THEME: black
#+REVEAL_TRANS: fade
#+REVEAL_EXTRA_CSS: talk.css
#+REVEAL_MARGIN: 0.0
#+HTML_HEAD: <link rel="stylesheet" href="notes.css"/>
#+PROPERTY: mkdirp yes
#+BEGIN_src elisp :exports none
  (org-export-define-derived-backend 'html-notes 'html
    :export-block '("NOTES")
    :translate-alist
    '((export-block . (lambda (el contents info)
                        (if (string= (org-element-property :type el) "NOTES")
                            (format "<div class=\"notes\">%s</div>"
                                    (org-export-string-as
                                     (org-element-property :value el)
                                     'html
                                     t)))))))
  (org-export-to-buffer 'html-notes "*Org Notes Export*")
#+END_src
# Local Variables:
# org-html-postamble: nil
# End:
* COMMENT Quotes
  16:18 <@steveklabnik> the whole idea of rust is that 'well if i'm careful it's okay' is a bad strategy

  The purpose of type systems goes far beyond type safety: They (also) serve to establish safe abstractions.

  Types are extremely important because they prevent us from writing nonsense.

  However, experience also shows that “being careful” and extensive testing is a time sink. Often, these efforts also leave serious errors in the code, causing crashes and security violations. We must do better.
  -- Bjarne Stroustrup, 2015
** Make illegal states unrepresentable
   you cannot construct values that contradict some desired invariants
* COMMENT What is XS
  #+BEGIN_NOTES
  Perl is a high-level language that allows us to write complicated programs easily, but it comes with a cost - it is somewhat slow. Most of the time it doesn't matter, but some things are very slow in Perl, like parsing binary protocols or doing complicated math.

  For these rare cases where performance matters, Perl has a C API and a set of supporting tools, known together as XS. It allows us to write very fast code that integrates nicely with Perl programs, but in return it exposes a lot Perl's internal workings and requires utmost care, since its very easy to break things.
  #+END_NOTES
* C example
  #+BEGIN_SRC perl :tangle xs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC perl -n :tangle lib/Foo.pm :exports none
    package Foo;
    use strict;
    use warnings;
    use feature 'say';

    use XSLoader;
    XSLoader::load();

    our @array = (1, 2, 3);

    sub routine {
        @array = ();
    }

    say Foo::badsub();

    1;
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/Foo.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c +n :tangle xs/Foo.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        SV **svp = av_fetch(av, 0, 0);  // my $svp = $Foo::array[0];
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = SvIV(*svp);
      }
      OUTPUT:
        RETVAL
  #+END_SRC
  #+BEGIN_NOTES
  Let me start with a simple example.

  This short XS function pulls a finds a global array, reads element at index zero, calls a subroutine and then returns said element as integer. I made a couple of careless mistakes here: not checking return values from =get_av= and =av_fetch= for NULLs, and keeping SV pointer around longer than necessary.

  =get_av()= on line 6 returns a pointer to a global array variable and will return a null pointer if variable "array" does not exist in the module. =av_fetch()= on line 7 tries to get an element 0 from the array, and will crash if =av= is null. =av_fetch()= will return a null pointer itself if the array is empty. On line 9 we call =SvIV()= to get the integer value of the array's element and it will crash too if the =svp= is null.

  Before that, on line 8, we call a perl sub called =undef_array=, which can introduce yet another bug in the code. Perl intentionally does not track pointers returned by =get_av()= or =av_fetch()=, so it doesn't know we still have them around. If =undef_array= does what its name suggests, =svp= will be pointing to unused memory location and our program crashes again.

  Of course, if I read docs and wrote my program more carefully all these bugs could have been avoided.
  #+END_NOTES
* A quote
  #+BEGIN_QUOTE
  However, experience also shows that “being careful” and extensive testing is a time sink. Often, these efforts also leave serious errors in the code, causing crashes and security violations. *We must do better.*
  #+END_QUOTE
  -- Bjarne Stroustrup et al, 2015
  #+BEGIN_NOTES
  However, experience also shows that "being careful" is a time sink and leaves serious errors in the code.
  #+END_NOTES
* What is Rust
  #+BEGIN_NOTES
  One way to do better, in my opinion, could be Rust, a new programming language that targets the same niche as C++, but with a stronger focus on program correctness. What if we had a safer, simpler and higher-level, but still reasonably fast way to write Perl extensions?
  #+END_NOTES
* C example fixed
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        if (av == NULL) croak("array is missing");

        SV **svp = av_fetch(av, 0, 0);
        if (svp == NULL) croak("element is missing");

        IV val = SvIV(*svp);

        PUSHMARK(SP);
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = val;
      }
      OUTPUT:
        RETVAL
  #+END_SRC
  #+BEGIN_NOTES
  To fix these problems we have to check all returned values and to make sure that we read svp as soon as we get it, before calling the routine. Rust won't do these things for us magically, but using Rust we can shape the API in the way that forces developer to check things that need checking, and gives them compile time errors if they don't.
  #+END_NOTES
* NULL pointers
  #+BEGIN_NOTES
  Lets deal with null pointers first.
  #+END_NOTES
** =enum= type
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer,
     }
     let drink = Drinks::Cola;
   #+END_SRC
   #+BEGIN_NOTES
   If you have worked with C, enum will look familiar. Here =Drinks= is a type that has only two possible values, =Cola= and =Beer=. We can make variable of =Drinks= and assign it one of the two values, but nothing else.
   #+END_NOTES
** With data
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer(String),
     }
     let drink = Drinks::Beer("Lager".to_string());
   #+END_SRC
   #+BEGIN_NOTES
   Enum variants in Rust can have additional data associated with them. Here, Cola is still a simple value, but Beer also has a String describing what kind of beer it is.
   #+END_NOTES
   #+ATTR_REVEAL: :frag t
   #+BEGIN_SRC rust +n
     match drink {
         Drinks::Cola => println!("Just cola"),
         Drinks::Beer(ref kind) => println!("{} beer", kind),
     }
   #+END_SRC
   #+BEGIN_NOTES
   The only way Rust allows us to access that string, is to check that drink is indeed a Beer. =match= operator is one way to do this. On the left side listed are enum variants, and on the right after the arrow is code that will be executed in that case. If a variant has associated data, we can assign it to a variable, but this variable only exists inside the Beer branch and Cola branch can not see it.
   #+END_NOTES
** Back to pointers
   #+BEGIN_SRC rust -n
     enum SafeSVPtr {
         Null,
         NotNull(*mut SV),
     }
   #+END_SRC
   #+BEGIN_NOTES
   Just what we need to avoid null pointers. Instead of returning a pointer directly, we can put it inside an enum with a separate case for null and dereferencing null pointer becomes impossible. This pattern applies not only to pointers of course, and is useful in so many different situations...
   #+END_NOTES
** Using standard library
   #+BEGIN_SRC rust -n
     enum Option<T> {
         None,
         Some(T),
     }
   #+END_SRC
   #+BEGIN_NOTES
   ...that Rust has enum just like that in the standard library. Letter 'T' in angle brackets on line 1 is called type parameter, which allows Option to hold all kinds of different types. match operator is often too bulky and verbose, so option comes with a variety of...
   #+END_NOTES
** Useful methods
   #+REVEAL_HTML: <table width="100%"><tr><td width="50%">
   Rust
   #+BEGIN_SRC rust
      foo.is_some()

      foo.expect("oh noes")

      foo.unwrap_or("default value")
   #+END_SRC
   #+BEGIN_NOTES
   ...useful methods. Here are a couple of examples, but there are many more. =is_some()= will return boolean true if foo is Some, =expect()= returns the value if there is one and throws a runtime exception if there isn't, and =unwrap_or()= returns the value from Some or a default value provided by the caller.
   #+END_NOTES

   #+REVEAL_HTML: </td><td width="50%">
   Perl
   #+BEGIN_SRC perl
      defined $foo

      $foo or die "oh noes"

      $foo // "default value"
    #+END_SRC
   #+REVEAL_HTML: </td></tr></table>
   #+BEGIN_NOTES
   Many of these functions have direct equivalents in Perl as well.
   #+END_NOTES
** Example
   #+BEGIN_SRC perl -n :tangle rs-fail1/Makefile.PL :exports none
     use inc::Module::Install;

     name "Foo";
     version "0.01";
     abstract "";

     rust_use_perl_xs { path => "../../perl-xs" };
     rust_write;

     WriteAll;
   #+END_SRC
   #+BEGIN_SRC rust :exports none :tangle rs-fail1/src/lib.rs
     #[macro_use]
     extern crate perl_xs;
     use perl_xs::{ Array, SV, AV };
     XS! {
         package Test {
             sub test (ctx) {
   #+END_SRC
   #+BEGIN_SRC rust -n :tangle rs-fail1/src/lib.rs
     let av: Option<AV> = ctx.get_av(cstr!("array"));

     let sv: Option<SV> = av.fetch(0);
      
   #+END_SRC
   #+BEGIN_SRC rust :exports none :tangle rs-fail1/src/lib.rs
             }
         }
         loader boot_Test;
     }
   #+END_SRC
   #+BEGIN_SRC text
     src/lib.rs:10:13: 10:21 error: no method named `fetch` found
                                    for type `core::option::Option<_>`
                                    in the current scope
     src/lib.rs:10 let sv: Option<SV> = av.fetch(0);
                                           ^~~~~~~~
   #+END_SRC
   #+BEGIN_NOTES
   So, the first two lines of the C example I started with end up looking like this in Rust. let keyword introduces new variables, then comes the variable name and its type after the colon. Variable types are optional most of the time, but here I write them for illustration. In Rust, both =get_av()= and =av_fetch()= return an Option instead of a pointer. And since av is an option, not an array, this code does not compile.
   #+END_NOTES
** Example
   #+BEGIN_SRC rust -n
     let av:        AV  = ctx.get_av(cstr!("array"))
                             .expect("array is missing");
     let sv:        SV  = av.fetch(0)
                            .expect("element is missing");
   #+END_SRC
   #+REVEAL_HTML: <pre class="src src-text"><br><br><br><br><br></pre>
   #+BEGIN_NOTES
   To fix the error we need to check if option contains the value we want, for example by using .expect() method. This code handles the possibility that array will be missing, and thus compiles without problem.
   #+END_NOTES
* Dangling pointers
  #+BEGIN_SRC c -n
        SV **svp = av_fetch(av, 0, 0);
        if (svp == NULL) croak("element is missing");
        // undef @av
        IV val = SvIV(*svp);
  #+END_SRC
  #+BEGIN_NOTES
  Next come the dangling pointer problem, when we a the pointer to already freed memory. Perl uses reference counting to make sure it doesn't free memory that someone has a pointer to, but, unfortunately, it doesn't help help here. What we have is a pointer to a pointer to an SV, and while we can tell Perl to keep that SV around, we can't prevent Perl from freeing array itself if someone does =undef= on it. The only really safe thing to do is to read =svp= as soon as we checked that it is not null.
  #+END_NOTES
** Traits
   #+BEGIN_SRC rust -n
     struct Square { side: f32 }
     struct Circle { radius: f32 }

     trait Area {
         fn area(&self) -> f32;
     }

     impl Area for Square {
         fn area(&self) -> f32 {
             self.side * self.side
         }
     }
     impl Area for Circle {
         fn area(&self) -> f32 {
             self.radius * self.radius * 3.14
         }
     }

     fn print_area<T: Area>(shape: T) {
         println!("Your area is {} cm²", shape.area());
     }
   #+END_SRC
   #+BEGIN_NOTES
   Trait tells the compiler about what methods a type provides. We start by defining new simple struct types, and a trait called Area on line 4, that has a single method called area. Following are two Area implementations for different types. There is fine print, but you can implement a trait for any type, even a built-in one. Traits are useful because they allow us to restrict number of types a generic function will work with. =print_area()= function on line 19 can work with both Squares and Circles, but calling it with something else will result in a compile-time error.
   #+END_NOTES
** From
   #+BEGIN_SRC rust -n
     trait FromSV {
         fn from(src: *mut SV) -> Self;
     }

     impl FromSV for IV {
         fn from(src: *mut SV) -> IV { SvIV(src) }
     }
     impl FromSV for NV {
         fn from(src: *mut SV) -> NV { SvNV(src) }
     }

     fn av_fetch<T: FromSV>(array: *mut AV, idx: IV) -> T {
         let temp: *mut SV = perl_av_fetch(array, idx);
         T::from(temp)
     }

     /* ... */
     let num: IV = av_fetch(my_array, 0);
   #+END_SRC
   #+BEGIN_NOTES
   Here, we define a trait FromSV, which describes a conversion from a raw SV pointer we got from the array into a safe value. We have two conversions defined, one for integers and another for floating point values. Line 12 is where the magic happens: we define a generic function =av_fetch()=, which can return any type 'T', as long as it implements =FromSV=, in other words, any type that can be produced from an SV. What T will be exactly is decided by the caller. On line 18 we use =av_fetch()= to get an integer value, T will be substituted with =IV= and method =from= on line 6 is called.
   #+END_NOTES
** FromSV for SV
   #+BEGIN_SRC perl -n
     my $x = $array[0];  # copy
     my $y = \$array[1]; # reference
   #+END_SRC
   #+BEGIN_SRC c -n
     SV* x = newSVsv(av_fetch(array, 0)); // copy
     SV* y = SvREFCNT_inc(av_fetch(array, 1)); // reference (kinda)
   #+END_SRC
   #+BEGIN_SRC rust -n
     impl FromSV for *mut SV {
         fn from(src: *mut SV) -> *mut SV { newSVsv(src) }
     }
   #+END_SRC
   #+BEGIN_NOTES
   Of course, developer may want to get an SV directly. We still need to read the double pointer, but then we can ask Perl to either make a new SV with the same value, or to to keep original SV around by incrementing its reference count. Either is fine, but it needs to happen. 
   #+END_NOTES
* In Rust
  #+BEGIN_SRC perl -n :tangle rs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    rust_use_perl_xs { path => "../../perl-xs" };
    rust_write;

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs :exports none
    #[macro_use]
    extern crate perl_xs;
    use perl_xs::{ SV, AV, Scalar, Array };
    use perl_xs::raw::{ G_VOID, G_DISCARD };
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs
    XS! {
        package Foo {
            sub badsub(ctx) {
                let av = ctx.get_av::<Option<AV>>(cstr!("array"))
                            .expect("array is missing");
                let sv = av.fetch::<Option<SV>>(0)
                           .expect("element is missing");
                ctx.call_pv(cstr!("routine"), G_VOID | G_DISCARD);
                xs_return!(ctx, sv.to_iv());
            }
        }
        loader boot_Foo;
    }
  #+END_SRC
  #+BEGIN_NOTES
  Putting all things together we get this. On line 4 =get_av()= is called. This weird syntax with double colons is used to explicitly to specify type parameters for a generic function in cases where it cannot be inferred automatically, like this one. Then we fetch first from the array, telling Rust API to return an SV. This SV is copy of the SV in the array so it will stay around as long as needed, and we can safely call =routine= before converting array element into integer and returning. =xs_return!= is a Rust macro that handles pushing return values from the =badsub= to the Perl stack and doing type conversions and other necessary bookkeeping as well.
  #+END_NOTES
* COMMENT Call builder prototype.
    http://is.gd/hDZvNU
* COMMENT Implementation details
** libouroboros for perl macros
** perl-sys for function declarations
** perl-xs for safe wrappers
* Problems
  #+BEGIN_NOTES
  This story would not be complete without mentioning some problems inherent to this approach.
  #+END_NOTES
** Exception handling
   #+BEGIN_NOTES
   Both Perl and Rust have their own ways of dealing with exceptions, which are, of course, not compatible with each other, and if any of Perl API method dies, it goes directly to the closest Perl eval, skipping all cleanup and destructor calls Rust must do when function returns. Not only this may leak memory, Rust standard library often relies on destructors to do things safely, and skipping any of that code is a very bad idea.
   #+END_NOTES
** No direct access to Perl internals
   #+BEGIN_NOTES
   Rust bindings cover only documented public part of Perl's API, but in C it is possible to call any Perl internal function.
   #+END_NOTES
** Rust supports far less platforms than Perl
   No IBM z/390, MS-DOS or HP-UX support
** A new language to learn
* Questions?
