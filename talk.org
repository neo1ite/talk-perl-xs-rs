* Rust inside Perl
#+STARTUP: overview hideblocks
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_title_slide:nil reveal_notes:t
#+REVEAL_ROOT: node_modules/reveal.js
#+REVEAL_THEME: black
#+REVEAL_TRANS: fade
#+REVEAL_EXTRA_CSS: talk.css
#+REVEAL_MARGIN: 0.0
#+HTML_HEAD: <link rel="stylesheet" href="notes.css"/>
#+PROPERTY: mkdirp yes
#+BEGIN_src elisp :exports none
  (org-export-define-derived-backend 'html-notes 'html
    :export-block '("NOTES")
    :translate-alist
    '((export-block . (lambda (el contents info)
                        (if (string= (org-element-property :type el) "NOTES")
                            (format "<div class=\"notes\">%s</div>"
                                    (org-export-string-as
                                     (org-element-property :value el)
                                     'html
                                     t)))))))
  (org-export-to-buffer 'html-notes "*Org Notes Export*")
#+END_src
# Local Variables:
# org-html-postamble: nil
# End:
* Make illegal states unrepresentable
  you cannot construct values that contradict some desired invariants
* Quotes
  16:18 <@steveklabnik> the whole idea of rust is that 'well if i'm careful it's okay' is a bad strategy

  The purpose of type systems goes far beyond type safety: They (also) serve to establish safe abstractions.

  Types are extremely important because they prevent us from writing nonsense.

  However, experience also shows that “being careful” and extensive testing is a time sink. Often, these efforts also leave serious errors in the code, causing crashes and security violations. We must do better.
  -- Bjarne Stroustrup, 2015
* What is XS
  why it is important
* C example
  #+BEGIN_SRC perl :tangle xs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/Foo.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c +n :tangle xs/Foo.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        SV **svp = av_fetch(av, 0, 0);
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = SvIV(*svp);
      }
      OUTPUT:
        RETVAL
  #+END_SRC
* Perl
  #+BEGIN_SRC perl -n :tangle lib/Foo.pm :exports none
    package Foo;
    use strict;
    use warnings;
    use feature 'say';
    use XSLoader;
    XSLoader::load();
  #+END_SRC
  #+BEGIN_SRC perl -n :tangle lib/Foo.pm
    package Foo;

    our @array = (1, 2, 3);

    sub routine {
        @array = ();
    }

    say Foo::badsub();

    1;
  #+END_SRC
* C example fixed
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs
    MODULE = Foo    PACKAGE = Foo
      int
      badsub()
        CODE:
        {
          AV *av = get_av("array", 0);
          if (av == NULL) croak("array is missing");
          SV **svp = av_fetch(av, 0, 0);
          if (svp == NULL) croak("element is missing");
          IV val = SvIV(*svp);
          PUSHMARK(SP);
          call_pv("routine", G_DISCARD | G_VOID);
          RETVAL = val;
        }
        OUTPUT:
          RETVAL
  #+END_SRC
* NULL pointers
** =enum= type
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer,
     }
     let drink = Drinks::Cola;
   #+END_SRC
** With data
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer(String),
     }
     let drink = Drinks::Beer("Lager".to_string());
   #+END_SRC
   #+ATTR_REVEAL: :frag t
   #+BEGIN_SRC rust +n
     match drink {
         Drinks::Cola => println!("Just cola"),
         Drinks::Beer(ref name) => println!("{} beer", name),
     }
   #+END_SRC
** Back to pointers
   #+BEGIN_SRC rust -n
     enum SafeSVPtr {
         Null,
         NotNull(*mut SV),
     }
   #+END_SRC
** Using standard library
   #+BEGIN_SRC rust -n
     enum Option<T> {
         None,
         Some(T),
     }
   #+END_SRC
** Useful methods
   #+BEGIN_SRC rust
     pub fn is_some(&self) -> bool;
     pub fn is_none(&self) -> bool;
     pub fn expect(self, msg: &str) -> T;
     pub fn unwrap_or(self, def: T) -> T;
    #+END_SRC
    and more
* Safe wrappers
** perl context and implic
** full, bare and temp handles
** Traits
   #+BEGIN_SRC rust -n
     struct Square { side: f32 }
     struct Circle { radius: f32 }

     trait Area {
         fn area(&self) -> f32;
     }

     impl Area for Square {
         fn area(&self) -> f32 {
             self.side * self.side
         }
     }
     impl Area for Circle {
         fn area(&self) -> f32 {
             self.radius * self.radius * 3.14
         }
     }
   #+END_SRC
** From
   #+BEGIN_SRC rust -n
     trait FromSV {
         fn from(src: *mut SV) -> Self;
     }

     impl FromSV for IV {
         fn from(src: *mut SV) -> IV { /* ... */ }
     }
     impl FromSV for NV {
         fn from(src: *mut SV) -> NV { /* ... */ }
     }

     fn av_fetch<T: FromSV>(array: *mut AV, idx: IV) -> T {
         T::from(perl_av_fetch(array, idx))
     }

     /* ... */
     let num: IV = av_fetch(my_array, 1, 0);
   #+END_SRC
** Refcounting and copying
   #+BEGIN_SRC perl -n
     my $x = $array[0];  # a copy of value
     my $y = \$array[1]; # a reference
   #+END_SRC
   #+BEGIN_SRC c -n
     SV* x = newSVsv(av_fetch(array, 0)); // copy
     SV* y = SvREFCNT_inc(av_fetch(array, 1)); // reference (kinda)
   #+END_SRC
* In Rust
  #+BEGIN_SRC perl -n :tangle rs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    rust_use_perl_xs { path => "../../perl-xs" };
    rust_write;

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs :exports none
    #[macro_use]
    extern crate perl_xs;
    use perl_xs::{ SV, AV, Scalar, Array };
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs
    XS! {
        package Foo {
            sub badsub(ctx) {
                let av = ctx.get_av::<Option<AV>>(cstr!("array"))
                            .expect("array is missing");
                let sv = av.fetch::<Option<SV>>(0)
                           .expect("element is missing");
                // ctx.new_call("routine").as_void().discard().call();
                xs_return!(ctx, sv.to_iv() * 2);
            }
        }
        loader boot_Foo;
    }
  #+END_SRC
  #+BEGIN_NOTES
    http://is.gd/hDZvNU
  #+END_NOTES
* Implementation details
** libouroboros for perl macros
** perl-sys for function declarations
** perl-xs for safe wrappers
* Drawbacks
** Need to learn Rust
** No direct access to Perl internals
** Less efficient that pure C
   * enum discriminator overhead
   * perl context pointer in every Full<SV>
   * macros not inlined
   * safety imposed restrictions
   * calls to Perl must catch exceptions
** No ppport.h for easy forward/backward compatibility
