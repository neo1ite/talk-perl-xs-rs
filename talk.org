* Rust inside Perl
#+STARTUP: overview hideblocks
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_title_slide:nil reveal_notes:t
#+REVEAL_ROOT: node_modules/reveal.js
#+REVEAL_THEME: black
#+REVEAL_TRANS: fade
#+REVEAL_EXTRA_CSS: talk.css
#+REVEAL_MARGIN: 0.0
#+HTML_HEAD: <link rel="stylesheet" href="notes.css"/>
#+PROPERTY: mkdirp yes
#+BEGIN_src elisp :exports none
  (org-export-define-derived-backend 'html-notes 'html
    :export-block '("NOTES")
    :translate-alist
    '((export-block . (lambda (el contents info)
                        (if (string= (org-element-property :type el) "NOTES")
                            (format "<div class=\"notes\">%s</div>"
                                    (org-export-string-as
                                     (org-element-property :value el)
                                     'html
                                     t)))))))
  (org-export-to-buffer 'html-notes "*Org Notes Export*")
#+END_src
# Local Variables:
# org-html-postamble: nil
# End:
* Make illegal states unrepresentable
  you cannot construct values that contradict some desired invariants
* Quotes
  16:18 <@steveklabnik> the whole idea of rust is that 'well if i'm careful it's okay' is a bad strategy

  The purpose of type systems goes far beyond type safety: They (also) serve to establish safe abstractions.

  Types are extremely important because they prevent us from writing nonsense.

  However, experience also shows that “being careful” and extensive testing is a time sink. Often, these efforts also leave serious errors in the code, causing crashes and security violations. We must do better.
  -- Bjarne Stroustrup, 2015
* C example
  #+BEGIN_SRC perl :tangle xs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/Foo.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c +n :tangle xs/Foo.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        SV **svp = av_fetch(av, 0, 0);
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = SvIV(*svp);
      }
      OUTPUT:
        RETVAL
  #+END_SRC
* Perl
  #+BEGIN_SRC perl +n :tangle lib/Foo.pm :exports none
    package Foo;
    use strict;
    use warnings;
    use feature 'say';
    use XSLoader;
    XSLoader::load();
  #+END_SRC
  #+BEGIN_SRC perl +n :tangle lib/Foo.pm
    package Foo;

    our @array = (1, 2, 3);

    sub routine {
        @array = ();
    }

    say Foo::badsub();

    1;
  #+END_SRC
* C example fixed
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c +n :tangle xs/FooFix.xs
    MODULE = Foo    PACKAGE = Foo
      int
      badsub()
        CODE:
        {
          AV *av = get_av("array", 0);
          if (av == NULL) croak("array is missing");
          SV **svp = av_fetch(av, 0, 0);
          if (svp == NULL) croak("element is missing");
          IV val = SvIV(*svp);
          PUSHMARK(SP);
          call_pv("routine", G_DISCARD | G_VOID);
          RETVAL = val;
        }
        OUTPUT:
          RETVAL
  #+END_SRC
* In Rust
  #+BEGIN_SRC perl -n :tangle rs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    rust_use_perl_xs { path => "../../perl-xs" };
    rust_write;

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs :exports none
    #[macro_use]
    extern crate perl_xs;
    use perl_xs::{ SV, AV, Scalar, Array };
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs
    XS! {
        package Foo {
            sub badsub(ctx) {
                let av: Option<AV> = ctx.get_av(cstr!("array"));
                let av: AV = av.expect("array is missing");
                let sv: Option<SV> = av.fetch(0);
                let sv: SV = sv.expect("element is missing");
                // ctx.new_call("routine").as_void().discard().call();
                xs_return!(ctx, sv.to_iv() * 2);
            }
        }
        loader boot_Foo;
    }
  #+END_SRC
