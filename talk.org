* Rust inside Perl
#+STARTUP: overview hideblocks
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_title_slide:nil reveal_notes:t
#+REVEAL_ROOT: node_modules/reveal.js
#+REVEAL_THEME: black
#+REVEAL_TRANS: fade
#+REVEAL_EXTRA_CSS: talk.css
#+REVEAL_MARGIN: 0.0
#+HTML_HEAD: <link rel="stylesheet" href="notes.css"/>
#+PROPERTY: mkdirp yes
#+BEGIN_src elisp :exports none
  (org-export-define-derived-backend 'html-notes 'html
    :export-block '("NOTES")
    :translate-alist
    '((export-block . (lambda (el contents info)
                        (if (string= (org-element-property :type el) "NOTES")
                            (format "<div class=\"notes\">%s</div>"
                                    (org-export-string-as
                                     (org-element-property :value el)
                                     'html
                                     t)))))))
  (org-export-to-buffer 'html-notes "*Org Notes Export*")
#+END_src
# Local Variables:
# org-html-postamble: nil
# End:
* COMMENT Quotes
  16:18 <@steveklabnik> the whole idea of rust is that 'well if i'm careful it's okay' is a bad strategy

  The purpose of type systems goes far beyond type safety: They (also) serve to establish safe abstractions.

  Types are extremely important because they prevent us from writing nonsense.

  However, experience also shows that “being careful” and extensive testing is a time sink. Often, these efforts also leave serious errors in the code, causing crashes and security violations. We must do better.
  -- Bjarne Stroustrup, 2015
** Make illegal states unrepresentable
   you cannot construct values that contradict some desired invariants
* What is XS
* What is Rust
* C example
  #+BEGIN_SRC perl :tangle xs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/Foo.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c +n :tangle xs/Foo.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        SV **svp = av_fetch(av, 0, 0);
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = SvIV(*svp);
      }
      OUTPUT:
        RETVAL
  #+END_SRC
* Perl
  #+BEGIN_SRC perl -n :tangle lib/Foo.pm :exports none
    package Foo;
    use strict;
    use warnings;
    use feature 'say';
    use XSLoader;
    XSLoader::load();
  #+END_SRC
  #+BEGIN_SRC perl -n :tangle lib/Foo.pm
    package Foo;

    our @array = (1, 2, 3);

    sub routine {
        @array = ();
    }

    say Foo::badsub();

    1;
  #+END_SRC
* C example fixed
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs :exports none
    #define PERL_NO_GET_CONTEXT
    #include "EXTERN.h"
    #include "perl.h"
    #include "XSUB.h"
  #+END_SRC
  #+BEGIN_SRC c -n :tangle xs/FooFix.xs
    MODULE = Foo    PACKAGE = Foo
    int
    badsub()
      CODE:
      {
        AV *av = get_av("array", 0);
        if (av == NULL) croak("array is missing");

        SV **svp = av_fetch(av, 0, 0);
        if (svp == NULL) croak("element is missing");

        IV val = SvIV(*svp);

        PUSHMARK(SP);
        call_pv("routine", G_DISCARD | G_VOID);
        RETVAL = val;
      }
      OUTPUT:
        RETVAL
  #+END_SRC
* NULL pointers
** =enum= type
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer,
     }
     let drink = Drinks::Cola;
   #+END_SRC
** With data
   #+BEGIN_SRC rust -n
     enum Drinks {
         Cola,
         Beer(String),
     }
     let drink = Drinks::Beer("Lager".to_string());
   #+END_SRC
   #+ATTR_REVEAL: :frag t
   #+BEGIN_SRC rust +n
     match drink {
         Drinks::Cola => println!("Just cola"),
         Drinks::Beer(ref name) => println!("{} beer", name),
     }
   #+END_SRC
** Back to pointers
   #+BEGIN_SRC rust -n
     enum SafeSVPtr {
         Null,
         NotNull(*mut SV),
     }
   #+END_SRC
** Using standard library
   #+BEGIN_SRC rust -n
     enum Option<T> {
         None,
         Some(T),
     }
   #+END_SRC
** Useful methods
   #+BEGIN_SRC rust
     pub fn is_some(&self) -> bool;
     pub fn is_none(&self) -> bool;
     pub fn expect(self, msg: &str) -> T;
     pub fn unwrap_or(self, def: T) -> T;
    #+END_SRC
    #+REVEAL_HTML: <table width="100%"><tr><td width="50%">
    Rust
    #+BEGIN_SRC rust
      foo().expect("oh noes");

      foo().unwrap_or("default value");
    #+END_SRC
    #+REVEAL_HTML: </td><td width="50%">
    Perl
    #+BEGIN_SRC perl
      foo() or die "oh noes";

      foo() // "default value";
    #+END_SRC
    #+REVEAL_HTML: </td></tr></table>
** Example
   #+BEGIN_SRC perl -n :tangle rs-fail1/Makefile.PL :exports none
     use inc::Module::Install;

     name "Foo";
     version "0.01";
     abstract "";

     rust_use_perl_xs { path => "../../perl-xs" };
     rust_write;

     WriteAll;
   #+END_SRC
   #+BEGIN_SRC rust :exports none :tangle rs-fail1/src/lib.rs
     #[macro_use]
     extern crate perl_xs;
     use perl_xs::{ Array, SV, AV };
     XS! {
         package Test {
             sub test (ctx) {
   #+END_SRC
   #+BEGIN_SRC rust -n :tangle rs-fail1/src/lib.rs
     let av: Option<AV> = ctx.get_av(cstr!("array"));

     let sv: Option<SV> = av.fetch(0);
      
   #+END_SRC
   #+BEGIN_SRC rust :exports none :tangle rs-fail1/src/lib.rs
             }
         }
         loader boot_Test;
     }
   #+END_SRC
   #+BEGIN_SRC text
     src/lib.rs:9:13: 9:21 error: no method named `fetch` found
                                  for type `core::option::Option<_>`
                                  in the current scope
     src/lib.rs:9 let sv: Option<SV> = av.fetch(0);
                                          ^~~~~~~~

   #+END_SRC
** Example
   #+BEGIN_SRC rust -n
     let av:        AV  = ctx.get_av(cstr!("array"))
                             .expect("array is missing");
     let sv:        SV  = av.fetch(0)
                            .expect("element is missing");
   #+END_SRC
   #+REVEAL_HTML: <pre class="src src-text"><br><br><br><br><br></pre>
* Dangling pointers
** Traits
   #+BEGIN_SRC rust -n
     struct Square { side: f32 }
     struct Circle { radius: f32 }

     trait Area {
         fn area(&self) -> f32;
     }

     impl Area for Square {
         fn area(&self) -> f32 {
             self.side * self.side
         }
     }
     impl Area for Circle {
         fn area(&self) -> f32 {
             self.radius * self.radius * 3.14
         }
     }
   #+END_SRC
** From
   #+BEGIN_SRC rust -n
     trait FromSV {
         fn from(src: *mut SV) -> Self;
     }

     impl FromSV for IV {
         fn from(src: *mut SV) -> IV { /* ... */ }
     }
     impl FromSV for NV {
         fn from(src: *mut SV) -> NV { /* ... */ }
     }

     fn av_fetch<T: FromSV>(array: *mut AV, idx: IV) -> T {
         T::from(perl_av_fetch(array, idx))
     }

     /* ... */
     let num: IV = av_fetch(my_array, 1, 0);
   #+END_SRC
** FromSV for SV
   #+BEGIN_SRC perl -n
     my $x = $array[0];  # a copy of value
     my $y = \$array[1]; # a reference
   #+END_SRC
   #+BEGIN_SRC c -n
     SV* x = newSVsv(av_fetch(array, 0)); // copy
     SV* y = SvREFCNT_inc(av_fetch(array, 1)); // reference (kinda)
   #+END_SRC
* In Rust
  #+BEGIN_SRC perl -n :tangle rs/Makefile.PL :exports none
    use inc::Module::Install;

    name "Foo";
    version "0.01";
    abstract "";

    rust_use_perl_xs { path => "../../perl-xs" };
    rust_write;

    WriteAll;
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs :exports none
    #[macro_use]
    extern crate perl_xs;
    use perl_xs::{ SV, AV, Scalar, Array };
  #+END_SRC
  #+BEGIN_SRC rust -n :tangle rs/src/lib.rs
    XS! {
        package Foo {
            sub badsub(ctx) {
                let av = ctx.get_av::<Option<AV>>(cstr!("array"))
                            .expect("array is missing");
                let sv = av.fetch::<Option<SV>>(0)
                           .expect("element is missing");
                // ctx.new_call("routine").as_void().discard().call();
                xs_return!(ctx, sv.to_iv() * 2);
            }
        }
        loader boot_Foo;
    }
  #+END_SRC
  #+BEGIN_NOTES
    http://is.gd/hDZvNU
  #+END_NOTES
* Implementation details
** libouroboros for perl macros
** perl-sys for function declarations
** perl-xs for safe wrappers
* Drawbacks
** Less platforms supported
   No IBM z/390 or MS-DOS support :-(
** Need to learn Rust
** No ppport.h for easy forward/backward compatibility
** No direct access to Perl internals
** Possibly will be less efficient that hand-crafted C
